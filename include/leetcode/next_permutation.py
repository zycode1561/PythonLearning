#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
给定一个序列，求这个序列的下一个排列：

123456->123465->123546->123564->124356->124365->124536->124563->
124635->124653->125346->...
每次我们从后往前找一个升序的排列，直到遇到非升序的数或者到达列表开头
然后我们从后面的升序序列中找到第一个比当前数大的数，我们从后往前找到第一个
比它大的数即可。然后交换两者的位置，最后对后面的升序序列进行一次反转操作即可

这里我感觉其实是用到了一种类似递归的思想，我们知道，当一个排列是降序的时候，他的下一个排列
就是把排列给反转过来，如果我们先固定左边第一个数字，如果右边是逆序的，那么我们就需要找到
逆序中比这个左边数大的最小的那个数和当前数字交换，然后对右边的数重新升序排序，如果不是逆序的，
那么说明当前的这个数组不是需要交换的,因为后面的数变大并不会影响到前面的数，所以我们就需要找到
最右边的降序，也就是从右到左的第一个升序，如果最右边的数要比它左边的数小，那么这个一数也可以看成
一个降序，直接按照规则交换即可。

如果数字重复呢？我们看题意，由于1322只能算为一个数，所以它的下一个数字只能是2123
1223->1232-> 1322 ->2123->2132->2213->2231->2312->2321->
所以说，我们直接略过这个2就好了，意思就是我们把相等也当作一个升序序列，就可以略过重复了

"""

__author__ = 'Zy_Code'


def nextPermutation(nums: list):
    i = len(nums) - 2
    while i >= 0 and nums[i + 1] <= nums[i]:
        i -= 1
    if i >= 0:
        j = len(nums) - 1
        while j >= 0 and nums[j] <= nums[i]:
            j -= 1
        nums[i], nums[j] = nums[j], nums[i]
    nums[i + 1:] = reversed(nums[i + 1:])


list1 = [4, 3, 2, 1]
nextPermutation(list1)
print(list1)
